<?php
/**
 * DestinatairesApi
 * PHP version 7.4
 *
 * @category Class
 * @package  MailevaApiAdapter\App\Client\LrCoproClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Maileva / Création et envoi de Maileva copro réservé aux professionnels de l'immobilier
 *
 * API pour créer et envoyer des Lettres Recommandées Copro réservées aux professionnels de l'immobilier.  En fonction du canal d'envoi défini, la Lettre Recommandée Copro sera envoyée de manière électronique ou papier.  Il est possible de définir un canal d'envoi (papier ou électronique) ou de passer par l'API <a href=\"/developpeur/electronic_consents\">electronic_consents</a> pour récupérer le canal d'envoi accepté par le destinataire.    Cette API comprend les fonctions clés pour :   - créer un envoi,  - ajouter des documents et des destinataires,  - choisir ses options (Nom, Champ libre, référence dossier, référence client)  - envoyer ses lettres recommandées copro  - gérer ses modes d'envoi : papier ou électronique  - suivre ses envois et télécharger les preuves de dépôt et justificatifs de réception.     **Paramétrage de compte expéditeur :**     Chaque expéditeur d'une Maileva Copro doit posséder un compte expéditeur. Il est donc nécessaire de paramétrer son compte expéditeur en passant par l'API <a href=\"/developpeur/electronic_mail_emitter\">electronic_mail_emitter</a> ou en se connectant à son espace client, depuis le lien reçu par notification e-mail et en suivant les étapes de paramétrage de compte.
 *
 * The version of the OpenAPI document: 1.37
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.3.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace MailevaApiAdapter\App\Client\LrCoproClient\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use MailevaApiAdapter\App\Client\LrCoproClient\ApiException;
use MailevaApiAdapter\App\Client\LrCoproClient\Configuration;
use MailevaApiAdapter\App\Client\LrCoproClient\HeaderSelector;
use MailevaApiAdapter\App\Client\LrCoproClient\ObjectSerializer;

/**
 * DestinatairesApi Class Doc Comment
 *
 * @category Class
 * @package  MailevaApiAdapter\App\Client\LrCoproClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DestinatairesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createRecipient' => [
            'application/json',
        ],
        'deleteAllRecipients' => [
            'application/json',
        ],
        'deleteRecipient' => [
            'application/json',
        ],
        'downloadDeliveryProof' => [
            'application/json',
        ],
        'downloadDepositProof' => [
            'application/json',
        ],
        'getRecipient' => [
            'application/json',
        ],
        'getRecipients' => [
            'application/json',
        ],
        'updateRecipient' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;

        $this->config->setHost($this->config->getHostFromSettings($hostIndex));
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createRecipient
     *
     * Ajout d&#39;un destinataire à l&#39;envoi
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  \MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientCreation $recipientCreation Nouveau destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRecipient'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto
     */
    public function createRecipient($authorization, $sendingId, $recipientCreation, string $contentType = self::contentTypes['createRecipient'][0])
    {
        list($response) = $this->createRecipientWithHttpInfo($authorization, $sendingId, $recipientCreation, $contentType);
        return $response;
    }

    /**
     * Operation createRecipientWithHttpInfo
     *
     * Ajout d&#39;un destinataire à l&#39;envoi
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  \MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientCreation $recipientCreation Nouveau destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRecipient'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRecipientWithHttpInfo($authorization, $sendingId, $recipientCreation, string $contentType = self::contentTypes['createRecipient'][0])
    {
        $request = $this->createRecipientRequest($authorization, $sendingId, $recipientCreation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createRecipientAsync
     *
     * Ajout d&#39;un destinataire à l&#39;envoi
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  \MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientCreation $recipientCreation Nouveau destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRecipient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRecipientAsync($authorization, $sendingId, $recipientCreation, string $contentType = self::contentTypes['createRecipient'][0])
    {
        return $this->createRecipientAsyncWithHttpInfo($authorization, $sendingId, $recipientCreation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRecipientAsyncWithHttpInfo
     *
     * Ajout d&#39;un destinataire à l&#39;envoi
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  \MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientCreation $recipientCreation Nouveau destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRecipient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRecipientAsyncWithHttpInfo($authorization, $sendingId, $recipientCreation, string $contentType = self::contentTypes['createRecipient'][0])
    {
        $returnType = '\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse';
        $request = $this->createRecipientRequest($authorization, $sendingId, $recipientCreation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRecipient'
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  \MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientCreation $recipientCreation Nouveau destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRecipient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRecipientRequest($authorization, $sendingId, $recipientCreation, string $contentType = self::contentTypes['createRecipient'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling createRecipient'
            );
        }

        // verify the required parameter 'sendingId' is set
        if ($sendingId === null || (is_array($sendingId) && count($sendingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingId when calling createRecipient'
            );
        }

        // verify the required parameter 'recipientCreation' is set
        if ($recipientCreation === null || (is_array($recipientCreation) && count($recipientCreation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recipientCreation when calling createRecipient'
            );
        }


        $resourcePath = '/sendings/{sending_id}/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($sendingId !== null) {
            $resourcePath = str_replace(
                '{' . 'sending_id' . '}',
                ObjectSerializer::toPathValue($sendingId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($recipientCreation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($recipientCreation));
            } else {
                $httpBody = $recipientCreation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAllRecipients
     *
     * Suppression de tous les destinataires
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllRecipients'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAllRecipients($authorization, $sendingId, string $contentType = self::contentTypes['deleteAllRecipients'][0])
    {
        $this->deleteAllRecipientsWithHttpInfo($authorization, $sendingId, $contentType);
    }

    /**
     * Operation deleteAllRecipientsWithHttpInfo
     *
     * Suppression de tous les destinataires
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllRecipients'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAllRecipientsWithHttpInfo($authorization, $sendingId, string $contentType = self::contentTypes['deleteAllRecipients'][0])
    {
        $request = $this->deleteAllRecipientsRequest($authorization, $sendingId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAllRecipientsAsync
     *
     * Suppression de tous les destinataires
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllRecipients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAllRecipientsAsync($authorization, $sendingId, string $contentType = self::contentTypes['deleteAllRecipients'][0])
    {
        return $this->deleteAllRecipientsAsyncWithHttpInfo($authorization, $sendingId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAllRecipientsAsyncWithHttpInfo
     *
     * Suppression de tous les destinataires
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllRecipients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAllRecipientsAsyncWithHttpInfo($authorization, $sendingId, string $contentType = self::contentTypes['deleteAllRecipients'][0])
    {
        $returnType = '';
        $request = $this->deleteAllRecipientsRequest($authorization, $sendingId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAllRecipients'
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllRecipients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAllRecipientsRequest($authorization, $sendingId, string $contentType = self::contentTypes['deleteAllRecipients'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling deleteAllRecipients'
            );
        }

        // verify the required parameter 'sendingId' is set
        if ($sendingId === null || (is_array($sendingId) && count($sendingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingId when calling deleteAllRecipients'
            );
        }


        $resourcePath = '/sendings/{sending_id}/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($sendingId !== null) {
            $resourcePath = str_replace(
                '{' . 'sending_id' . '}',
                ObjectSerializer::toPathValue($sendingId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRecipient
     *
     * Suppression d&#39;un destinataire
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecipient'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRecipient($authorization, $sendingId, $recipientId, string $contentType = self::contentTypes['deleteRecipient'][0])
    {
        $this->deleteRecipientWithHttpInfo($authorization, $sendingId, $recipientId, $contentType);
    }

    /**
     * Operation deleteRecipientWithHttpInfo
     *
     * Suppression d&#39;un destinataire
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecipient'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRecipientWithHttpInfo($authorization, $sendingId, $recipientId, string $contentType = self::contentTypes['deleteRecipient'][0])
    {
        $request = $this->deleteRecipientRequest($authorization, $sendingId, $recipientId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRecipientAsync
     *
     * Suppression d&#39;un destinataire
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecipient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRecipientAsync($authorization, $sendingId, $recipientId, string $contentType = self::contentTypes['deleteRecipient'][0])
    {
        return $this->deleteRecipientAsyncWithHttpInfo($authorization, $sendingId, $recipientId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRecipientAsyncWithHttpInfo
     *
     * Suppression d&#39;un destinataire
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecipient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRecipientAsyncWithHttpInfo($authorization, $sendingId, $recipientId, string $contentType = self::contentTypes['deleteRecipient'][0])
    {
        $returnType = '';
        $request = $this->deleteRecipientRequest($authorization, $sendingId, $recipientId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRecipient'
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecipient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteRecipientRequest($authorization, $sendingId, $recipientId, string $contentType = self::contentTypes['deleteRecipient'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling deleteRecipient'
            );
        }

        // verify the required parameter 'sendingId' is set
        if ($sendingId === null || (is_array($sendingId) && count($sendingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingId when calling deleteRecipient'
            );
        }

        // verify the required parameter 'recipientId' is set
        if ($recipientId === null || (is_array($recipientId) && count($recipientId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recipientId when calling deleteRecipient'
            );
        }


        $resourcePath = '/sendings/{sending_id}/recipients/{recipient_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($sendingId !== null) {
            $resourcePath = str_replace(
                '{' . 'sending_id' . '}',
                ObjectSerializer::toPathValue($sendingId),
                $resourcePath
            );
        }
        // path params
        if ($recipientId !== null) {
            $resourcePath = str_replace(
                '{' . 'recipient_id' . '}',
                ObjectSerializer::toPathValue($recipientId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadDeliveryProof
     *
     * Télécharger le justificatif de réception du destinataire (accusé de reception, refus ou non réclamation)
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadDeliveryProof'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto
     */
    public function downloadDeliveryProof($sendingId, $recipientId, string $contentType = self::contentTypes['downloadDeliveryProof'][0])
    {
        list($response) = $this->downloadDeliveryProofWithHttpInfo($sendingId, $recipientId, $contentType);
        return $response;
    }

    /**
     * Operation downloadDeliveryProofWithHttpInfo
     *
     * Télécharger le justificatif de réception du destinataire (accusé de reception, refus ou non réclamation)
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadDeliveryProof'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadDeliveryProofWithHttpInfo($sendingId, $recipientId, string $contentType = self::contentTypes['downloadDeliveryProof'][0])
    {
        $request = $this->downloadDeliveryProofRequest($sendingId, $recipientId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadDeliveryProofAsync
     *
     * Télécharger le justificatif de réception du destinataire (accusé de reception, refus ou non réclamation)
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadDeliveryProof'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadDeliveryProofAsync($sendingId, $recipientId, string $contentType = self::contentTypes['downloadDeliveryProof'][0])
    {
        return $this->downloadDeliveryProofAsyncWithHttpInfo($sendingId, $recipientId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadDeliveryProofAsyncWithHttpInfo
     *
     * Télécharger le justificatif de réception du destinataire (accusé de reception, refus ou non réclamation)
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadDeliveryProof'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadDeliveryProofAsyncWithHttpInfo($sendingId, $recipientId, string $contentType = self::contentTypes['downloadDeliveryProof'][0])
    {
        $returnType = 'string';
        $request = $this->downloadDeliveryProofRequest($sendingId, $recipientId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadDeliveryProof'
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadDeliveryProof'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadDeliveryProofRequest($sendingId, $recipientId, string $contentType = self::contentTypes['downloadDeliveryProof'][0])
    {

        // verify the required parameter 'sendingId' is set
        if ($sendingId === null || (is_array($sendingId) && count($sendingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingId when calling downloadDeliveryProof'
            );
        }

        // verify the required parameter 'recipientId' is set
        if ($recipientId === null || (is_array($recipientId) && count($recipientId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recipientId when calling downloadDeliveryProof'
            );
        }


        $resourcePath = '/sendings/{sending_id}/recipients/{recipient_id}/download_delivery_proof';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sendingId !== null) {
            $resourcePath = str_replace(
                '{' . 'sending_id' . '}',
                ObjectSerializer::toPathValue($sendingId),
                $resourcePath
            );
        }
        // path params
        if ($recipientId !== null) {
            $resourcePath = str_replace(
                '{' . 'recipient_id' . '}',
                ObjectSerializer::toPathValue($recipientId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadDepositProof
     *
     * Télécharger la preuve de dépot du destinataire
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadDepositProof'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto
     */
    public function downloadDepositProof($authorization, $sendingId, $recipientId, string $contentType = self::contentTypes['downloadDepositProof'][0])
    {
        list($response) = $this->downloadDepositProofWithHttpInfo($authorization, $sendingId, $recipientId, $contentType);
        return $response;
    }

    /**
     * Operation downloadDepositProofWithHttpInfo
     *
     * Télécharger la preuve de dépot du destinataire
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadDepositProof'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadDepositProofWithHttpInfo($authorization, $sendingId, $recipientId, string $contentType = self::contentTypes['downloadDepositProof'][0])
    {
        $request = $this->downloadDepositProofRequest($authorization, $sendingId, $recipientId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadDepositProofAsync
     *
     * Télécharger la preuve de dépot du destinataire
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadDepositProof'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadDepositProofAsync($authorization, $sendingId, $recipientId, string $contentType = self::contentTypes['downloadDepositProof'][0])
    {
        return $this->downloadDepositProofAsyncWithHttpInfo($authorization, $sendingId, $recipientId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadDepositProofAsyncWithHttpInfo
     *
     * Télécharger la preuve de dépot du destinataire
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadDepositProof'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadDepositProofAsyncWithHttpInfo($authorization, $sendingId, $recipientId, string $contentType = self::contentTypes['downloadDepositProof'][0])
    {
        $returnType = 'string';
        $request = $this->downloadDepositProofRequest($authorization, $sendingId, $recipientId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadDepositProof'
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadDepositProof'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadDepositProofRequest($authorization, $sendingId, $recipientId, string $contentType = self::contentTypes['downloadDepositProof'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling downloadDepositProof'
            );
        }

        // verify the required parameter 'sendingId' is set
        if ($sendingId === null || (is_array($sendingId) && count($sendingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingId when calling downloadDepositProof'
            );
        }

        // verify the required parameter 'recipientId' is set
        if ($recipientId === null || (is_array($recipientId) && count($recipientId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recipientId when calling downloadDepositProof'
            );
        }


        $resourcePath = '/sendings/{sending_id}/recipients/{recipient_id}/download_deposit_proof';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($sendingId !== null) {
            $resourcePath = str_replace(
                '{' . 'sending_id' . '}',
                ObjectSerializer::toPathValue($sendingId),
                $resourcePath
            );
        }
        // path params
        if ($recipientId !== null) {
            $resourcePath = str_replace(
                '{' . 'recipient_id' . '}',
                ObjectSerializer::toPathValue($recipientId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipient
     *
     * Détail d&#39;un destinataire
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipient'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto
     */
    public function getRecipient($authorization, $sendingId, $recipientId, string $contentType = self::contentTypes['getRecipient'][0])
    {
        list($response) = $this->getRecipientWithHttpInfo($authorization, $sendingId, $recipientId, $contentType);
        return $response;
    }

    /**
     * Operation getRecipientWithHttpInfo
     *
     * Détail d&#39;un destinataire
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipient'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipientWithHttpInfo($authorization, $sendingId, $recipientId, string $contentType = self::contentTypes['getRecipient'][0])
    {
        $request = $this->getRecipientRequest($authorization, $sendingId, $recipientId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipientAsync
     *
     * Détail d&#39;un destinataire
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipientAsync($authorization, $sendingId, $recipientId, string $contentType = self::contentTypes['getRecipient'][0])
    {
        return $this->getRecipientAsyncWithHttpInfo($authorization, $sendingId, $recipientId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipientAsyncWithHttpInfo
     *
     * Détail d&#39;un destinataire
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipientAsyncWithHttpInfo($authorization, $sendingId, $recipientId, string $contentType = self::contentTypes['getRecipient'][0])
    {
        $returnType = '\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse';
        $request = $this->getRecipientRequest($authorization, $sendingId, $recipientId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipient'
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecipientRequest($authorization, $sendingId, $recipientId, string $contentType = self::contentTypes['getRecipient'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getRecipient'
            );
        }

        // verify the required parameter 'sendingId' is set
        if ($sendingId === null || (is_array($sendingId) && count($sendingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingId when calling getRecipient'
            );
        }

        // verify the required parameter 'recipientId' is set
        if ($recipientId === null || (is_array($recipientId) && count($recipientId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recipientId when calling getRecipient'
            );
        }


        $resourcePath = '/sendings/{sending_id}/recipients/{recipient_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($sendingId !== null) {
            $resourcePath = str_replace(
                '{' . 'sending_id' . '}',
                ObjectSerializer::toPathValue($sendingId),
                $resourcePath
            );
        }
        // path params
        if ($recipientId !== null) {
            $resourcePath = str_replace(
                '{' . 'recipient_id' . '}',
                ObjectSerializer::toPathValue($recipientId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipients
     *
     * Liste des destinataires d&#39;un envoi
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId sendingId (required)
     * @param  int $startIndex Le premier élément à retourner (optional, default to 1)
     * @param  int $count Le nombre d&#39;élément à retourner (optional, default to 50)
     * @param  string $sort sort (optional)
     * @param  string $desc desc (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipients'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientsResponse|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto
     */
    public function getRecipients($authorization, $sendingId, $startIndex = 1, $count = 50, $sort = null, $desc = null, string $contentType = self::contentTypes['getRecipients'][0])
    {
        list($response) = $this->getRecipientsWithHttpInfo($authorization, $sendingId, $startIndex, $count, $sort, $desc, $contentType);
        return $response;
    }

    /**
     * Operation getRecipientsWithHttpInfo
     *
     * Liste des destinataires d&#39;un envoi
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId (required)
     * @param  int $startIndex Le premier élément à retourner (optional, default to 1)
     * @param  int $count Le nombre d&#39;élément à retourner (optional, default to 50)
     * @param  string $sort (optional)
     * @param  string $desc (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipients'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientsResponse|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipientsWithHttpInfo($authorization, $sendingId, $startIndex = 1, $count = 50, $sort = null, $desc = null, string $contentType = self::contentTypes['getRecipients'][0])
    {
        $request = $this->getRecipientsRequest($authorization, $sendingId, $startIndex, $count, $sort, $desc, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipientsAsync
     *
     * Liste des destinataires d&#39;un envoi
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId (required)
     * @param  int $startIndex Le premier élément à retourner (optional, default to 1)
     * @param  int $count Le nombre d&#39;élément à retourner (optional, default to 50)
     * @param  string $sort (optional)
     * @param  string $desc (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipientsAsync($authorization, $sendingId, $startIndex = 1, $count = 50, $sort = null, $desc = null, string $contentType = self::contentTypes['getRecipients'][0])
    {
        return $this->getRecipientsAsyncWithHttpInfo($authorization, $sendingId, $startIndex, $count, $sort, $desc, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipientsAsyncWithHttpInfo
     *
     * Liste des destinataires d&#39;un envoi
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId (required)
     * @param  int $startIndex Le premier élément à retourner (optional, default to 1)
     * @param  int $count Le nombre d&#39;élément à retourner (optional, default to 50)
     * @param  string $sort (optional)
     * @param  string $desc (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipientsAsyncWithHttpInfo($authorization, $sendingId, $startIndex = 1, $count = 50, $sort = null, $desc = null, string $contentType = self::contentTypes['getRecipients'][0])
    {
        $returnType = '\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientsResponse';
        $request = $this->getRecipientsRequest($authorization, $sendingId, $startIndex, $count, $sort, $desc, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipients'
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId (required)
     * @param  int $startIndex Le premier élément à retourner (optional, default to 1)
     * @param  int $count Le nombre d&#39;élément à retourner (optional, default to 50)
     * @param  string $sort (optional)
     * @param  string $desc (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecipientsRequest($authorization, $sendingId, $startIndex = 1, $count = 50, $sort = null, $desc = null, string $contentType = self::contentTypes['getRecipients'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getRecipients'
            );
        }

        // verify the required parameter 'sendingId' is set
        if ($sendingId === null || (is_array($sendingId) && count($sendingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingId when calling getRecipients'
            );
        }

        if ($startIndex !== null && $startIndex < 1) {
            throw new \InvalidArgumentException('invalid value for "$startIndex" when calling DestinatairesApi.getRecipients, must be bigger than or equal to 1.');
        }
        
        if ($count !== null && $count < 1) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling DestinatairesApi.getRecipients, must be bigger than or equal to 1.');
        }
        



        $resourcePath = '/sendings/{sending_id}/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startIndex,
            'start_index', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $desc,
            'desc', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($sendingId !== null) {
            $resourcePath = str_replace(
                '{' . 'sending_id' . '}',
                ObjectSerializer::toPathValue($sendingId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateRecipient
     *
     * Modification partielle d&#39;un destinataire
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  \MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientUpdate $recipientUpdate recipientUpdate (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateRecipient'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto
     */
    public function updateRecipient($authorization, $sendingId, $recipientId, $recipientUpdate, string $contentType = self::contentTypes['updateRecipient'][0])
    {
        list($response) = $this->updateRecipientWithHttpInfo($authorization, $sendingId, $recipientId, $recipientUpdate, $contentType);
        return $response;
    }

    /**
     * Operation updateRecipientWithHttpInfo
     *
     * Modification partielle d&#39;un destinataire
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  \MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientUpdate $recipientUpdate (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateRecipient'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateRecipientWithHttpInfo($authorization, $sendingId, $recipientId, $recipientUpdate, string $contentType = self::contentTypes['updateRecipient'][0])
    {
        $request = $this->updateRecipientRequest($authorization, $sendingId, $recipientId, $recipientUpdate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateRecipientAsync
     *
     * Modification partielle d&#39;un destinataire
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  \MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientUpdate $recipientUpdate (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateRecipient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateRecipientAsync($authorization, $sendingId, $recipientId, $recipientUpdate, string $contentType = self::contentTypes['updateRecipient'][0])
    {
        return $this->updateRecipientAsyncWithHttpInfo($authorization, $sendingId, $recipientId, $recipientUpdate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateRecipientAsyncWithHttpInfo
     *
     * Modification partielle d&#39;un destinataire
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  \MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientUpdate $recipientUpdate (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateRecipient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateRecipientAsyncWithHttpInfo($authorization, $sendingId, $recipientId, $recipientUpdate, string $contentType = self::contentTypes['updateRecipient'][0])
    {
        $returnType = '\MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientResponse';
        $request = $this->updateRecipientRequest($authorization, $sendingId, $recipientId, $recipientUpdate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateRecipient'
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $recipientId Identifiant du destinataire (required)
     * @param  \MailevaApiAdapter\App\Client\LrCoproClient\Model\RecipientUpdate $recipientUpdate (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateRecipient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateRecipientRequest($authorization, $sendingId, $recipientId, $recipientUpdate, string $contentType = self::contentTypes['updateRecipient'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling updateRecipient'
            );
        }

        // verify the required parameter 'sendingId' is set
        if ($sendingId === null || (is_array($sendingId) && count($sendingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingId when calling updateRecipient'
            );
        }

        // verify the required parameter 'recipientId' is set
        if ($recipientId === null || (is_array($recipientId) && count($recipientId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recipientId when calling updateRecipient'
            );
        }

        // verify the required parameter 'recipientUpdate' is set
        if ($recipientUpdate === null || (is_array($recipientUpdate) && count($recipientUpdate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recipientUpdate when calling updateRecipient'
            );
        }


        $resourcePath = '/sendings/{sending_id}/recipients/{recipient_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($sendingId !== null) {
            $resourcePath = str_replace(
                '{' . 'sending_id' . '}',
                ObjectSerializer::toPathValue($sendingId),
                $resourcePath
            );
        }
        // path params
        if ($recipientId !== null) {
            $resourcePath = str_replace(
                '{' . 'recipient_id' . '}',
                ObjectSerializer::toPathValue($recipientId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($recipientUpdate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($recipientUpdate));
            } else {
                $httpBody = $recipientUpdate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
