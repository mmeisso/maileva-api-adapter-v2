<?php
/**
 * DocumentsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  MailevaApiAdapter\App\Client\LrCoproClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Maileva / Création et envoi de Maileva copro réservé aux professionnels de l'immobilier
 *
 * API pour créer et envoyer des Lettres Recommandées Copro réservées aux professionnels de l'immobilier.  En fonction du canal d'envoi défini, la Lettre Recommandée Copro sera envoyée de manière électronique ou papier.  Il est possible de définir un canal d'envoi (papier ou électronique) ou de passer par l'API <a href=\"/developpeur/electronic_consents\">electronic_consents</a> pour récupérer le canal d'envoi accepté par le destinataire.    Cette API comprend les fonctions clés pour :   - créer un envoi,  - ajouter des documents et des destinataires,  - choisir ses options (Nom, Champ libre, référence dossier, référence client)  - envoyer ses lettres recommandées copro  - gérer ses modes d'envoi : papier ou électronique  - suivre ses envois et télécharger les preuves de dépôt et justificatifs de réception.     **Paramétrage de compte expéditeur :**     Chaque expéditeur d'une Maileva Copro doit posséder un compte expéditeur. Il est donc nécessaire de paramétrer son compte expéditeur en passant par l'API <a href=\"/developpeur/electronic_mail_emitter\">electronic_mail_emitter</a> ou en se connectant à son espace client, depuis le lien reçu par notification e-mail et en suivant les étapes de paramétrage de compte.
 *
 * The version of the OpenAPI document: 1.37
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.3.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace MailevaApiAdapter\App\Client\LrCoproClient\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use MailevaApiAdapter\App\Client\LrCoproClient\ApiException;
use MailevaApiAdapter\App\Client\LrCoproClient\Configuration;
use MailevaApiAdapter\App\Client\LrCoproClient\HeaderSelector;
use MailevaApiAdapter\App\Client\LrCoproClient\ObjectSerializer;

/**
 * DocumentsApi Class Doc Comment
 *
 * @category Class
 * @package  MailevaApiAdapter\App\Client\LrCoproClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DocumentsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createDocument' => [
            'multipart/form-data',
        ],
        'deleteDocument' => [
            'application/json',
        ],
        'getDocument' => [
            'application/json',
        ],
        'getDocuments' => [
            'application/json',
        ],
        'updateDocument' => [
            'multipart/form-data',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;

        $this->config->setHost($this->config->getHostFromSettings($hostIndex));
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createDocument
     *
     * Ajout d&#39;un document à l&#39;envoi.
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  \SplFileObject $document document (required)
     * @param  \MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentCreationMetadata $metadata metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDocument'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto
     */
    public function createDocument($authorization, $sendingId, $document, $metadata = null, string $contentType = self::contentTypes['createDocument'][0])
    {
        list($response) = $this->createDocumentWithHttpInfo($authorization, $sendingId, $document, $metadata, $contentType);
        return $response;
    }

    /**
     * Operation createDocumentWithHttpInfo
     *
     * Ajout d&#39;un document à l&#39;envoi.
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  \SplFileObject $document (required)
     * @param  \MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentCreationMetadata $metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDocument'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDocumentWithHttpInfo($authorization, $sendingId, $document, $metadata = null, string $contentType = self::contentTypes['createDocument'][0])
    {
        $request = $this->createDocumentRequest($authorization, $sendingId, $document, $metadata, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDocumentAsync
     *
     * Ajout d&#39;un document à l&#39;envoi.
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  \SplFileObject $document (required)
     * @param  \MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentCreationMetadata $metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDocumentAsync($authorization, $sendingId, $document, $metadata = null, string $contentType = self::contentTypes['createDocument'][0])
    {
        return $this->createDocumentAsyncWithHttpInfo($authorization, $sendingId, $document, $metadata, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDocumentAsyncWithHttpInfo
     *
     * Ajout d&#39;un document à l&#39;envoi.
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  \SplFileObject $document (required)
     * @param  \MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentCreationMetadata $metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDocumentAsyncWithHttpInfo($authorization, $sendingId, $document, $metadata = null, string $contentType = self::contentTypes['createDocument'][0])
    {
        $returnType = '\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse';
        $request = $this->createDocumentRequest($authorization, $sendingId, $document, $metadata, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDocument'
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  \SplFileObject $document (required)
     * @param  \MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentCreationMetadata $metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDocumentRequest($authorization, $sendingId, $document, $metadata = null, string $contentType = self::contentTypes['createDocument'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling createDocument'
            );
        }

        // verify the required parameter 'sendingId' is set
        if ($sendingId === null || (is_array($sendingId) && count($sendingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingId when calling createDocument'
            );
        }

        // verify the required parameter 'document' is set
        if ($document === null || (is_array($document) && count($document) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document when calling createDocument'
            );
        }



        $resourcePath = '/sendings/{sending_id}/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($sendingId !== null) {
            $resourcePath = str_replace(
                '{' . 'sending_id' . '}',
                ObjectSerializer::toPathValue($sendingId),
                $resourcePath
            );
        }

        // form params
        if ($document !== null) {
            $multipart = true;
            $formParams['document'] = [];
            $paramFiles = is_array($document) ? $document : [$document];
            foreach ($paramFiles as $paramFile) {
                $formParams['document'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }
        // form params
        if ($metadata !== null) {
            $formParams['metadata'] = ObjectSerializer::toFormValue($metadata);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDocument
     *
     * Suppression d&#39;un document
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $documentId Identifiant du document (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDocument'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteDocument($authorization, $sendingId, $documentId, string $contentType = self::contentTypes['deleteDocument'][0])
    {
        $this->deleteDocumentWithHttpInfo($authorization, $sendingId, $documentId, $contentType);
    }

    /**
     * Operation deleteDocumentWithHttpInfo
     *
     * Suppression d&#39;un document
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $documentId Identifiant du document (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDocument'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDocumentWithHttpInfo($authorization, $sendingId, $documentId, string $contentType = self::contentTypes['deleteDocument'][0])
    {
        $request = $this->deleteDocumentRequest($authorization, $sendingId, $documentId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDocumentAsync
     *
     * Suppression d&#39;un document
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $documentId Identifiant du document (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentAsync($authorization, $sendingId, $documentId, string $contentType = self::contentTypes['deleteDocument'][0])
    {
        return $this->deleteDocumentAsyncWithHttpInfo($authorization, $sendingId, $documentId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDocumentAsyncWithHttpInfo
     *
     * Suppression d&#39;un document
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $documentId Identifiant du document (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentAsyncWithHttpInfo($authorization, $sendingId, $documentId, string $contentType = self::contentTypes['deleteDocument'][0])
    {
        $returnType = '';
        $request = $this->deleteDocumentRequest($authorization, $sendingId, $documentId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDocument'
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $documentId Identifiant du document (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteDocumentRequest($authorization, $sendingId, $documentId, string $contentType = self::contentTypes['deleteDocument'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling deleteDocument'
            );
        }

        // verify the required parameter 'sendingId' is set
        if ($sendingId === null || (is_array($sendingId) && count($sendingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingId when calling deleteDocument'
            );
        }

        // verify the required parameter 'documentId' is set
        if ($documentId === null || (is_array($documentId) && count($documentId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $documentId when calling deleteDocument'
            );
        }


        $resourcePath = '/sendings/{sending_id}/documents/{document_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($sendingId !== null) {
            $resourcePath = str_replace(
                '{' . 'sending_id' . '}',
                ObjectSerializer::toPathValue($sendingId),
                $resourcePath
            );
        }
        // path params
        if ($documentId !== null) {
            $resourcePath = str_replace(
                '{' . 'document_id' . '}',
                ObjectSerializer::toPathValue($documentId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocument
     *
     * Détail d&#39;un document
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $documentId Identifiant du document (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocument'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorResponse|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorResponse
     */
    public function getDocument($authorization, $sendingId, $documentId, string $contentType = self::contentTypes['getDocument'][0])
    {
        list($response) = $this->getDocumentWithHttpInfo($authorization, $sendingId, $documentId, $contentType);
        return $response;
    }

    /**
     * Operation getDocumentWithHttpInfo
     *
     * Détail d&#39;un document
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $documentId Identifiant du document (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocument'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorResponse|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentWithHttpInfo($authorization, $sendingId, $documentId, string $contentType = self::contentTypes['getDocument'][0])
    {
        $request = $this->getDocumentRequest($authorization, $sendingId, $documentId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentAsync
     *
     * Détail d&#39;un document
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $documentId Identifiant du document (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAsync($authorization, $sendingId, $documentId, string $contentType = self::contentTypes['getDocument'][0])
    {
        return $this->getDocumentAsyncWithHttpInfo($authorization, $sendingId, $documentId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentAsyncWithHttpInfo
     *
     * Détail d&#39;un document
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $documentId Identifiant du document (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAsyncWithHttpInfo($authorization, $sendingId, $documentId, string $contentType = self::contentTypes['getDocument'][0])
    {
        $returnType = '\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse';
        $request = $this->getDocumentRequest($authorization, $sendingId, $documentId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocument'
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $documentId Identifiant du document (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDocumentRequest($authorization, $sendingId, $documentId, string $contentType = self::contentTypes['getDocument'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getDocument'
            );
        }

        // verify the required parameter 'sendingId' is set
        if ($sendingId === null || (is_array($sendingId) && count($sendingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingId when calling getDocument'
            );
        }

        // verify the required parameter 'documentId' is set
        if ($documentId === null || (is_array($documentId) && count($documentId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $documentId when calling getDocument'
            );
        }


        $resourcePath = '/sendings/{sending_id}/documents/{document_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($sendingId !== null) {
            $resourcePath = str_replace(
                '{' . 'sending_id' . '}',
                ObjectSerializer::toPathValue($sendingId),
                $resourcePath
            );
        }
        // path params
        if ($documentId !== null) {
            $resourcePath = str_replace(
                '{' . 'document_id' . '}',
                ObjectSerializer::toPathValue($documentId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocuments
     *
     * Liste des documents d&#39;un envoi
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  int $startIndex Le premier élément à retourner (optional, default to 1)
     * @param  int $count Le nombre d&#39;élément à retourner (optional, default to 30)
     * @param  string $sort sort (optional)
     * @param  string $desc desc (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocuments'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentsResponse|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto
     */
    public function getDocuments($authorization, $sendingId, $startIndex = 1, $count = 30, $sort = null, $desc = null, string $contentType = self::contentTypes['getDocuments'][0])
    {
        list($response) = $this->getDocumentsWithHttpInfo($authorization, $sendingId, $startIndex, $count, $sort, $desc, $contentType);
        return $response;
    }

    /**
     * Operation getDocumentsWithHttpInfo
     *
     * Liste des documents d&#39;un envoi
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  int $startIndex Le premier élément à retourner (optional, default to 1)
     * @param  int $count Le nombre d&#39;élément à retourner (optional, default to 30)
     * @param  string $sort (optional)
     * @param  string $desc (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocuments'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentsResponse|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentsWithHttpInfo($authorization, $sendingId, $startIndex = 1, $count = 30, $sort = null, $desc = null, string $contentType = self::contentTypes['getDocuments'][0])
    {
        $request = $this->getDocumentsRequest($authorization, $sendingId, $startIndex, $count, $sort, $desc, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentsAsync
     *
     * Liste des documents d&#39;un envoi
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  int $startIndex Le premier élément à retourner (optional, default to 1)
     * @param  int $count Le nombre d&#39;élément à retourner (optional, default to 30)
     * @param  string $sort (optional)
     * @param  string $desc (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentsAsync($authorization, $sendingId, $startIndex = 1, $count = 30, $sort = null, $desc = null, string $contentType = self::contentTypes['getDocuments'][0])
    {
        return $this->getDocumentsAsyncWithHttpInfo($authorization, $sendingId, $startIndex, $count, $sort, $desc, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentsAsyncWithHttpInfo
     *
     * Liste des documents d&#39;un envoi
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  int $startIndex Le premier élément à retourner (optional, default to 1)
     * @param  int $count Le nombre d&#39;élément à retourner (optional, default to 30)
     * @param  string $sort (optional)
     * @param  string $desc (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentsAsyncWithHttpInfo($authorization, $sendingId, $startIndex = 1, $count = 30, $sort = null, $desc = null, string $contentType = self::contentTypes['getDocuments'][0])
    {
        $returnType = '\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentsResponse';
        $request = $this->getDocumentsRequest($authorization, $sendingId, $startIndex, $count, $sort, $desc, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocuments'
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  int $startIndex Le premier élément à retourner (optional, default to 1)
     * @param  int $count Le nombre d&#39;élément à retourner (optional, default to 30)
     * @param  string $sort (optional)
     * @param  string $desc (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDocumentsRequest($authorization, $sendingId, $startIndex = 1, $count = 30, $sort = null, $desc = null, string $contentType = self::contentTypes['getDocuments'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getDocuments'
            );
        }

        // verify the required parameter 'sendingId' is set
        if ($sendingId === null || (is_array($sendingId) && count($sendingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingId when calling getDocuments'
            );
        }

        if ($startIndex !== null && $startIndex < 1) {
            throw new \InvalidArgumentException('invalid value for "$startIndex" when calling DocumentsApi.getDocuments, must be bigger than or equal to 1.');
        }
        
        if ($count !== null && $count < 1) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling DocumentsApi.getDocuments, must be bigger than or equal to 1.');
        }
        



        $resourcePath = '/sendings/{sending_id}/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startIndex,
            'start_index', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $desc,
            'desc', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($sendingId !== null) {
            $resourcePath = str_replace(
                '{' . 'sending_id' . '}',
                ObjectSerializer::toPathValue($sendingId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDocument
     *
     * Modification des metadata d&#39;un document
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $documentId Identifiant du document (required)
     * @param  \MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentUpdateMetadata $metadata metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDocument'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto
     */
    public function updateDocument($authorization, $sendingId, $documentId, $metadata = null, string $contentType = self::contentTypes['updateDocument'][0])
    {
        list($response) = $this->updateDocumentWithHttpInfo($authorization, $sendingId, $documentId, $metadata, $contentType);
        return $response;
    }

    /**
     * Operation updateDocumentWithHttpInfo
     *
     * Modification des metadata d&#39;un document
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $documentId Identifiant du document (required)
     * @param  \MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentUpdateMetadata $metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDocument'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\LrCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto|\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDocumentWithHttpInfo($authorization, $sendingId, $documentId, $metadata = null, string $contentType = self::contentTypes['updateDocument'][0])
    {
        $request = $this->updateDocumentRequest($authorization, $sendingId, $documentId, $metadata, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\LrCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateDocumentAsync
     *
     * Modification des metadata d&#39;un document
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $documentId Identifiant du document (required)
     * @param  \MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentUpdateMetadata $metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDocumentAsync($authorization, $sendingId, $documentId, $metadata = null, string $contentType = self::contentTypes['updateDocument'][0])
    {
        return $this->updateDocumentAsyncWithHttpInfo($authorization, $sendingId, $documentId, $metadata, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDocumentAsyncWithHttpInfo
     *
     * Modification des metadata d&#39;un document
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $documentId Identifiant du document (required)
     * @param  \MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentUpdateMetadata $metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDocumentAsyncWithHttpInfo($authorization, $sendingId, $documentId, $metadata = null, string $contentType = self::contentTypes['updateDocument'][0])
    {
        $returnType = '\MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentResponse';
        $request = $this->updateDocumentRequest($authorization, $sendingId, $documentId, $metadata, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDocument'
     *
     * @param  string $authorization Bearer {access_token} (required)
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $documentId Identifiant du document (required)
     * @param  \MailevaApiAdapter\App\Client\LrCoproClient\Model\DocumentUpdateMetadata $metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateDocumentRequest($authorization, $sendingId, $documentId, $metadata = null, string $contentType = self::contentTypes['updateDocument'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling updateDocument'
            );
        }

        // verify the required parameter 'sendingId' is set
        if ($sendingId === null || (is_array($sendingId) && count($sendingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingId when calling updateDocument'
            );
        }

        // verify the required parameter 'documentId' is set
        if ($documentId === null || (is_array($documentId) && count($documentId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $documentId when calling updateDocument'
            );
        }



        $resourcePath = '/sendings/{sending_id}/documents/{document_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($sendingId !== null) {
            $resourcePath = str_replace(
                '{' . 'sending_id' . '}',
                ObjectSerializer::toPathValue($sendingId),
                $resourcePath
            );
        }
        // path params
        if ($documentId !== null) {
            $resourcePath = str_replace(
                '{' . 'document_id' . '}',
                ObjectSerializer::toPathValue($documentId),
                $resourcePath
            );
        }

        // form params
        if ($metadata !== null) {
            $formParams['metadata'] = ObjectSerializer::toFormValue($metadata);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
