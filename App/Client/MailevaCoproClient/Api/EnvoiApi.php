<?php
/**
 * EnvoiApi
 * PHP version 7.4
 *
 * @category Class
 * @package  MailevaApiAdapter\App\Client\MailevaCoproClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Maileva / Création et envoi de Maileva copro réservé aux professionnels de l'immobilier
 *
 * API pour créer et envoyer des Lettres Recommandées Copro réservées aux professionnels de l'immobilier.  En fonction du canal d'envoi défini, la Lettre Recommandée Copro sera envoyée de manière électronique ou papier.  Il est possible de définir un canal d'envoi (papier ou électronique) ou de passer par l'API <a href=\"/developpeur/electronic_consents\">electronic_consents</a> pour récupérer le canal d'envoi accepté par le destinataire.    Cette API comprend les fonctions clés pour :   - créer un envoi,  - ajouter des documents et des destinataires,  - choisir ses options (Nom, Champ libre, référence dossier, référence client)  - envoyer ses lettres recommandées copro  - gérer ses modes d'envoi : papier ou électronique  - suivre ses envois et télécharger les preuves de dépôt et justificatifs de réception.     **Paramétrage de compte expéditeur :**     Chaque expéditeur d'une Maileva Copro doit posséder un compte expéditeur. Il est donc nécessaire de paramétrer son compte expéditeur en passant par l'API <a href=\"/developpeur/electronic_mail_emitter\">electronic_mail_emitter</a> ou en se connectant à son espace client, depuis le lien reçu par notification e-mail et en suivant les étapes de paramétrage de compte.
 *
 * The version of the OpenAPI document: 1.37
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.3.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace MailevaApiAdapter\App\Client\MailevaCoproClient\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use MailevaApiAdapter\App\Client\MailevaCoproClient\ApiException;
use MailevaApiAdapter\App\Client\MailevaCoproClient\Configuration;
use MailevaApiAdapter\App\Client\MailevaCoproClient\HeaderSelector;
use MailevaApiAdapter\App\Client\MailevaCoproClient\ObjectSerializer;

/**
 * EnvoiApi Class Doc Comment
 *
 * @category Class
 * @package  MailevaApiAdapter\App\Client\MailevaCoproClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class EnvoiApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'checkSending' => [
            'application/json',
        ],
        'createSending' => [
            'application/json',
        ],
        'deleteSending' => [
            'application/json',
        ],
        'findSendings' => [
            'application/json',
        ],
        'getCheckSending' => [
            'application/json',
        ],
        'getSending' => [
            'application/json',
        ],
        'getSubmitSending' => [
            'application/json',
        ],
        'submitSending' => [
            'application/json',
        ],
        'updateSending' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation checkSending
     *
     * Vérification de l&#39;envoi avant soumission
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkSending'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\MailevaCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function checkSending($sendingId, string $contentType = self::contentTypes['checkSending'][0])
    {
        $this->checkSendingWithHttpInfo($sendingId, $contentType);
    }

    /**
     * Operation checkSendingWithHttpInfo
     *
     * Vérification de l&#39;envoi avant soumission
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkSending'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\MailevaCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkSendingWithHttpInfo($sendingId, string $contentType = self::contentTypes['checkSending'][0])
    {
        $request = $this->checkSendingRequest($sendingId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation checkSendingAsync
     *
     * Vérification de l&#39;envoi avant soumission
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkSendingAsync($sendingId, string $contentType = self::contentTypes['checkSending'][0])
    {
        return $this->checkSendingAsyncWithHttpInfo($sendingId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkSendingAsyncWithHttpInfo
     *
     * Vérification de l&#39;envoi avant soumission
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkSendingAsyncWithHttpInfo($sendingId, string $contentType = self::contentTypes['checkSending'][0])
    {
        $returnType = '';
        $request = $this->checkSendingRequest($sendingId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkSending'
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkSendingRequest($sendingId, string $contentType = self::contentTypes['checkSending'][0])
    {

        // verify the required parameter 'sendingId' is set
        if ($sendingId === null || (is_array($sendingId) && count($sendingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingId when calling checkSending'
            );
        }


        $resourcePath = '/sendings/{sending_id}/check';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sendingId !== null) {
            $resourcePath = str_replace(
                '{' . 'sending_id' . '}',
                ObjectSerializer::toPathValue($sendingId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createSending
     *
     * Création d&#39;un envoi
     *
     * @param  \MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingCreation $sendingCreation Nouvel envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSending'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\MailevaCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse|\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto
     */
    public function createSending($sendingCreation, string $contentType = self::contentTypes['createSending'][0])
    {
        list($response) = $this->createSendingWithHttpInfo($sendingCreation, $contentType);
        return $response;
    }

    /**
     * Operation createSendingWithHttpInfo
     *
     * Création d&#39;un envoi
     *
     * @param  \MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingCreation $sendingCreation Nouvel envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSending'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\MailevaCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse|\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createSendingWithHttpInfo($sendingCreation, string $contentType = self::contentTypes['createSending'][0])
    {
        $request = $this->createSendingRequest($sendingCreation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createSendingAsync
     *
     * Création d&#39;un envoi
     *
     * @param  \MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingCreation $sendingCreation Nouvel envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSendingAsync($sendingCreation, string $contentType = self::contentTypes['createSending'][0])
    {
        return $this->createSendingAsyncWithHttpInfo($sendingCreation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createSendingAsyncWithHttpInfo
     *
     * Création d&#39;un envoi
     *
     * @param  \MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingCreation $sendingCreation Nouvel envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSendingAsyncWithHttpInfo($sendingCreation, string $contentType = self::contentTypes['createSending'][0])
    {
        $returnType = '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse';
        $request = $this->createSendingRequest($sendingCreation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createSending'
     *
     * @param  \MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingCreation $sendingCreation Nouvel envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createSendingRequest($sendingCreation, string $contentType = self::contentTypes['createSending'][0])
    {

        // verify the required parameter 'sendingCreation' is set
        if ($sendingCreation === null || (is_array($sendingCreation) && count($sendingCreation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingCreation when calling createSending'
            );
        }


        $resourcePath = '/sendings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sendingCreation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($sendingCreation));
            } else {
                $httpBody = $sendingCreation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteSending
     *
     * Suppression d&#39;un envoi
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSending'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\MailevaCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteSending($sendingId, string $contentType = self::contentTypes['deleteSending'][0])
    {
        $this->deleteSendingWithHttpInfo($sendingId, $contentType);
    }

    /**
     * Operation deleteSendingWithHttpInfo
     *
     * Suppression d&#39;un envoi
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSending'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\MailevaCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteSendingWithHttpInfo($sendingId, string $contentType = self::contentTypes['deleteSending'][0])
    {
        $request = $this->deleteSendingRequest($sendingId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteSendingAsync
     *
     * Suppression d&#39;un envoi
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSendingAsync($sendingId, string $contentType = self::contentTypes['deleteSending'][0])
    {
        return $this->deleteSendingAsyncWithHttpInfo($sendingId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteSendingAsyncWithHttpInfo
     *
     * Suppression d&#39;un envoi
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSendingAsyncWithHttpInfo($sendingId, string $contentType = self::contentTypes['deleteSending'][0])
    {
        $returnType = '';
        $request = $this->deleteSendingRequest($sendingId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteSending'
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteSendingRequest($sendingId, string $contentType = self::contentTypes['deleteSending'][0])
    {

        // verify the required parameter 'sendingId' is set
        if ($sendingId === null || (is_array($sendingId) && count($sendingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingId when calling deleteSending'
            );
        }


        $resourcePath = '/sendings/{sending_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sendingId !== null) {
            $resourcePath = str_replace(
                '{' . 'sending_id' . '}',
                ObjectSerializer::toPathValue($sendingId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findSendings
     *
     * Liste des envois
     *
     * @param  int $startIndex Le premier élément à retourner (optional, default to 1)
     * @param  int $count Le nombre d&#39;élément à retourner (optional, default to 50)
     * @param  string $sort sort (optional)
     * @param  string $desc desc (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findSendings'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\MailevaCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingsResponse|\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto
     */
    public function findSendings($startIndex = 1, $count = 50, $sort = null, $desc = null, string $contentType = self::contentTypes['findSendings'][0])
    {
        list($response) = $this->findSendingsWithHttpInfo($startIndex, $count, $sort, $desc, $contentType);
        return $response;
    }

    /**
     * Operation findSendingsWithHttpInfo
     *
     * Liste des envois
     *
     * @param  int $startIndex Le premier élément à retourner (optional, default to 1)
     * @param  int $count Le nombre d&#39;élément à retourner (optional, default to 50)
     * @param  string $sort (optional)
     * @param  string $desc (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findSendings'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\MailevaCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingsResponse|\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function findSendingsWithHttpInfo($startIndex = 1, $count = 50, $sort = null, $desc = null, string $contentType = self::contentTypes['findSendings'][0])
    {
        $request = $this->findSendingsRequest($startIndex, $count, $sort, $desc, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findSendingsAsync
     *
     * Liste des envois
     *
     * @param  int $startIndex Le premier élément à retourner (optional, default to 1)
     * @param  int $count Le nombre d&#39;élément à retourner (optional, default to 50)
     * @param  string $sort (optional)
     * @param  string $desc (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findSendings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findSendingsAsync($startIndex = 1, $count = 50, $sort = null, $desc = null, string $contentType = self::contentTypes['findSendings'][0])
    {
        return $this->findSendingsAsyncWithHttpInfo($startIndex, $count, $sort, $desc, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findSendingsAsyncWithHttpInfo
     *
     * Liste des envois
     *
     * @param  int $startIndex Le premier élément à retourner (optional, default to 1)
     * @param  int $count Le nombre d&#39;élément à retourner (optional, default to 50)
     * @param  string $sort (optional)
     * @param  string $desc (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findSendings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findSendingsAsyncWithHttpInfo($startIndex = 1, $count = 50, $sort = null, $desc = null, string $contentType = self::contentTypes['findSendings'][0])
    {
        $returnType = '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingsResponse';
        $request = $this->findSendingsRequest($startIndex, $count, $sort, $desc, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findSendings'
     *
     * @param  int $startIndex Le premier élément à retourner (optional, default to 1)
     * @param  int $count Le nombre d&#39;élément à retourner (optional, default to 50)
     * @param  string $sort (optional)
     * @param  string $desc (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['findSendings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function findSendingsRequest($startIndex = 1, $count = 50, $sort = null, $desc = null, string $contentType = self::contentTypes['findSendings'][0])
    {

        if ($startIndex !== null && $startIndex < 1) {
            throw new \InvalidArgumentException('invalid value for "$startIndex" when calling EnvoiApi.findSendings, must be bigger than or equal to 1.');
        }
        
        if ($count !== null && $count < 1) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling EnvoiApi.findSendings, must be bigger than or equal to 1.');
        }
        



        $resourcePath = '/sendings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startIndex,
            'start_index', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $desc,
            'desc', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCheckSending
     *
     * Liste des envois vérifiés avant soumission
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckSending'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\MailevaCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getCheckSending($sendingId, string $contentType = self::contentTypes['getCheckSending'][0])
    {
        $this->getCheckSendingWithHttpInfo($sendingId, $contentType);
    }

    /**
     * Operation getCheckSendingWithHttpInfo
     *
     * Liste des envois vérifiés avant soumission
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckSending'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\MailevaCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCheckSendingWithHttpInfo($sendingId, string $contentType = self::contentTypes['getCheckSending'][0])
    {
        $request = $this->getCheckSendingRequest($sendingId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCheckSendingAsync
     *
     * Liste des envois vérifiés avant soumission
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCheckSendingAsync($sendingId, string $contentType = self::contentTypes['getCheckSending'][0])
    {
        return $this->getCheckSendingAsyncWithHttpInfo($sendingId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCheckSendingAsyncWithHttpInfo
     *
     * Liste des envois vérifiés avant soumission
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCheckSendingAsyncWithHttpInfo($sendingId, string $contentType = self::contentTypes['getCheckSending'][0])
    {
        $returnType = '';
        $request = $this->getCheckSendingRequest($sendingId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCheckSending'
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCheckSendingRequest($sendingId, string $contentType = self::contentTypes['getCheckSending'][0])
    {

        // verify the required parameter 'sendingId' is set
        if ($sendingId === null || (is_array($sendingId) && count($sendingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingId when calling getCheckSending'
            );
        }


        $resourcePath = '/sendings/{sending_id}/check';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sendingId !== null) {
            $resourcePath = str_replace(
                '{' . 'sending_id' . '}',
                ObjectSerializer::toPathValue($sendingId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSending
     *
     * Détail d&#39;un envoi
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSending'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\MailevaCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse|\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto
     */
    public function getSending($sendingId, string $contentType = self::contentTypes['getSending'][0])
    {
        list($response) = $this->getSendingWithHttpInfo($sendingId, $contentType);
        return $response;
    }

    /**
     * Operation getSendingWithHttpInfo
     *
     * Détail d&#39;un envoi
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSending'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\MailevaCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse|\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSendingWithHttpInfo($sendingId, string $contentType = self::contentTypes['getSending'][0])
    {
        $request = $this->getSendingRequest($sendingId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSendingAsync
     *
     * Détail d&#39;un envoi
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSendingAsync($sendingId, string $contentType = self::contentTypes['getSending'][0])
    {
        return $this->getSendingAsyncWithHttpInfo($sendingId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSendingAsyncWithHttpInfo
     *
     * Détail d&#39;un envoi
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSendingAsyncWithHttpInfo($sendingId, string $contentType = self::contentTypes['getSending'][0])
    {
        $returnType = '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse';
        $request = $this->getSendingRequest($sendingId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSending'
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSendingRequest($sendingId, string $contentType = self::contentTypes['getSending'][0])
    {

        // verify the required parameter 'sendingId' is set
        if ($sendingId === null || (is_array($sendingId) && count($sendingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingId when calling getSending'
            );
        }


        $resourcePath = '/sendings/{sending_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sendingId !== null) {
            $resourcePath = str_replace(
                '{' . 'sending_id' . '}',
                ObjectSerializer::toPathValue($sendingId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSubmitSending
     *
     * Contrôle l&#39;état d&#39;un envoi après soumission
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmitSending'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\MailevaCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getSubmitSending($sendingId, string $contentType = self::contentTypes['getSubmitSending'][0])
    {
        $this->getSubmitSendingWithHttpInfo($sendingId, $contentType);
    }

    /**
     * Operation getSubmitSendingWithHttpInfo
     *
     * Contrôle l&#39;état d&#39;un envoi après soumission
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmitSending'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\MailevaCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSubmitSendingWithHttpInfo($sendingId, string $contentType = self::contentTypes['getSubmitSending'][0])
    {
        $request = $this->getSubmitSendingRequest($sendingId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSubmitSendingAsync
     *
     * Contrôle l&#39;état d&#39;un envoi après soumission
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmitSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubmitSendingAsync($sendingId, string $contentType = self::contentTypes['getSubmitSending'][0])
    {
        return $this->getSubmitSendingAsyncWithHttpInfo($sendingId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSubmitSendingAsyncWithHttpInfo
     *
     * Contrôle l&#39;état d&#39;un envoi après soumission
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmitSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubmitSendingAsyncWithHttpInfo($sendingId, string $contentType = self::contentTypes['getSubmitSending'][0])
    {
        $returnType = '';
        $request = $this->getSubmitSendingRequest($sendingId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSubmitSending'
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmitSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSubmitSendingRequest($sendingId, string $contentType = self::contentTypes['getSubmitSending'][0])
    {

        // verify the required parameter 'sendingId' is set
        if ($sendingId === null || (is_array($sendingId) && count($sendingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingId when calling getSubmitSending'
            );
        }


        $resourcePath = '/sendings/{sending_id}/submit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sendingId !== null) {
            $resourcePath = str_replace(
                '{' . 'sending_id' . '}',
                ObjectSerializer::toPathValue($sendingId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation submitSending
     *
     * Finalisation d&#39;un envoi
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['submitSending'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\MailevaCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function submitSending($sendingId, string $contentType = self::contentTypes['submitSending'][0])
    {
        $this->submitSendingWithHttpInfo($sendingId, $contentType);
    }

    /**
     * Operation submitSendingWithHttpInfo
     *
     * Finalisation d&#39;un envoi
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['submitSending'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\MailevaCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function submitSendingWithHttpInfo($sendingId, string $contentType = self::contentTypes['submitSending'][0])
    {
        $request = $this->submitSendingRequest($sendingId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation submitSendingAsync
     *
     * Finalisation d&#39;un envoi
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['submitSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function submitSendingAsync($sendingId, string $contentType = self::contentTypes['submitSending'][0])
    {
        return $this->submitSendingAsyncWithHttpInfo($sendingId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation submitSendingAsyncWithHttpInfo
     *
     * Finalisation d&#39;un envoi
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['submitSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function submitSendingAsyncWithHttpInfo($sendingId, string $contentType = self::contentTypes['submitSending'][0])
    {
        $returnType = '';
        $request = $this->submitSendingRequest($sendingId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'submitSending'
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['submitSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function submitSendingRequest($sendingId, string $contentType = self::contentTypes['submitSending'][0])
    {

        // verify the required parameter 'sendingId' is set
        if ($sendingId === null || (is_array($sendingId) && count($sendingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingId when calling submitSending'
            );
        }


        $resourcePath = '/sendings/{sending_id}/submit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sendingId !== null) {
            $resourcePath = str_replace(
                '{' . 'sending_id' . '}',
                ObjectSerializer::toPathValue($sendingId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateSending
     *
     * Modification des options d&#39;envoi
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  \MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingUpdate $sendingUpdate sendingUpdate (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSending'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\MailevaCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse|\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto
     */
    public function updateSending($sendingId, $sendingUpdate, string $contentType = self::contentTypes['updateSending'][0])
    {
        list($response) = $this->updateSendingWithHttpInfo($sendingId, $sendingUpdate, $contentType);
        return $response;
    }

    /**
     * Operation updateSendingWithHttpInfo
     *
     * Modification des options d&#39;envoi
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  \MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingUpdate $sendingUpdate (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSending'] to see the possible values for this operation
     *
     * @throws \MailevaApiAdapter\App\Client\MailevaCoproClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse|\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateSendingWithHttpInfo($sendingId, $sendingUpdate, string $contentType = self::contentTypes['updateSending'][0])
    {
        $request = $this->updateSendingRequest($sendingId, $sendingUpdate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\ErrorsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateSendingAsync
     *
     * Modification des options d&#39;envoi
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  \MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingUpdate $sendingUpdate (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSendingAsync($sendingId, $sendingUpdate, string $contentType = self::contentTypes['updateSending'][0])
    {
        return $this->updateSendingAsyncWithHttpInfo($sendingId, $sendingUpdate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateSendingAsyncWithHttpInfo
     *
     * Modification des options d&#39;envoi
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  \MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingUpdate $sendingUpdate (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSendingAsyncWithHttpInfo($sendingId, $sendingUpdate, string $contentType = self::contentTypes['updateSending'][0])
    {
        $returnType = '\MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingResponse';
        $request = $this->updateSendingRequest($sendingId, $sendingUpdate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateSending'
     *
     * @param  string $sendingId Identifiant de l&#39;envoi (required)
     * @param  \MailevaApiAdapter\App\Client\MailevaCoproClient\Model\SendingUpdate $sendingUpdate (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateSendingRequest($sendingId, $sendingUpdate, string $contentType = self::contentTypes['updateSending'][0])
    {

        // verify the required parameter 'sendingId' is set
        if ($sendingId === null || (is_array($sendingId) && count($sendingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingId when calling updateSending'
            );
        }

        // verify the required parameter 'sendingUpdate' is set
        if ($sendingUpdate === null || (is_array($sendingUpdate) && count($sendingUpdate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendingUpdate when calling updateSending'
            );
        }


        $resourcePath = '/sendings/{sending_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sendingId !== null) {
            $resourcePath = str_replace(
                '{' . 'sending_id' . '}',
                ObjectSerializer::toPathValue($sendingId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sendingUpdate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($sendingUpdate));
            } else {
                $httpBody = $sendingUpdate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
